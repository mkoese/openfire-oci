namespace:
  name: openfire
  create: true

image:
  repository: openfire-oci
  tag: "5.0.3"
  pullPolicy: IfNotPresent

timezone: Europe/Zurich

replicaCount: 1

service:
  type: ClusterIP
  ports:
    xmpp: 5222
    xmppSsl: 5223
    s2s: 5269
    s2sSsl: 5270
    component: 5275
    componentSsl: 5276
    bosh: 7070
    boshSsl: 7443
    fileTransfer: 7777
    admin: 9090
    adminSsl: 9091

loadBalancer:
  enabled: false
  # annotations: {}  # cloud provider annotations

routes:
  admin:
    enabled: false
    # host: openfire-admin.apps.example.com
  adminSsl:
    enabled: false
    # host: openfire-admin-ssl.apps.example.com
  bosh:
    enabled: false
    # host: openfire-bosh.apps.example.com
  boshSsl:
    enabled: false
    # host: openfire-bosh-ssl.apps.example.com

persistence:
  storageClassName: ""
  data:
    size: 1Gi
  plugins:
    size: 512Mi

# JVM flags â€” overrides Containerfile JAVA_OPTS.
javaOpts:
  - -XX:+UseContainerSupport              # respect cgroup memory/CPU limits
  - -XX:MaxRAMPercentage=75.0             # max heap as percentage of container memory limit
  - -XX:+UseG1GC                          # low-latency garbage collector
  - -XX:+ExitOnOutOfMemoryError           # crash fast instead of running degraded
  - -Dlog4j2.formatMsgNoLookups=true      # CVE-2021-44228 (Log4Shell) mitigation
  - -Djava.security.egd=file:/dev/urandom # non-blocking entropy for faster TLS handshakes

tls:
  # Kubernetes secret containing key "keystore-password". If empty, uses Java default.
  keystorePasswordSecret: ""
  # Kubernetes TLS secret (tls.crt, tls.key) from an official CA.
  # When empty, init container generates a self-signed certificate.
  secretName: ""
  # ConfigMap with trusted CA certificates (e.g., config-trusted-cabundle).
  # Each key with a .crt or .pem extension is imported into the truststore.
  trustedCAConfigMap: ""

resources:
  limits:
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi
